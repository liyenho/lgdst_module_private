/*
 *
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!
 */
#include "si446x_nirq.h"
#include <string.h>
#include "radio.h"
#include "ctrl.h"

#ifdef RADIO_SI4463
 #include "si446x_api_lib.h"
 void si4463_radio_handler(const uint32_t id, const uint32_t index);
	volatile si446x_pckt_hdlr_pend pkt;
	volatile si446x_mdm_hdlr_pend  mdm;
	volatile si446x_chip_hdlr_pend chip;
	volatile uint16_t temp1_intm;	// also read by user temperature query
	static uint8_t tune_cap_str[] = {RF_GLOBAL_XO_TUNE_2};
	extern uint32_t ul_page_addr_ctune, ul_page_addr_mtemp;
	extern uint8_t tune_cap_str[];
	// time instrumentation
	extern volatile uint32_t *DWT_CYCCNT;
	extern volatile uint32_t gs_rdo_rpacket[RDO_RPACKET_FIFO_SIZE*RDO_ELEMENT_SIZE];
  extern unsigned int *gp_rdo_rpacket, *gp_rdo_rpacket_l;

	extern volatile uint32_t rpacket_idle[RDO_ELEMENT_SIZE];
  extern uint32_t rpacket_ov[RDO_ELEMENT_SIZE];
	extern unsigned char gs_rdo_rpacket_ovflw;
	extern volatile uint32_t wrptr_rdo_rpacket, rdptr_rdo_rpacket;
	extern volatile unsigned char bMain_IT_Status, bMain_IT_Status_m; // as global ctrl radio intr flag...
	extern volatile bool ctrl_tdma_enable ;
	 extern volatile capv_tune_t si4463_factory_tune;
	  extern bool timedelta_reset_rx ;
	  extern volatile bool ctrl_tdma_lock;
		extern volatile bool fhop_in_search, fhop_flag;
	  extern unsigned int tdma_sndthr;
	  extern unsigned int  radio_mon_rxcnt;
    extern unsigned int radio_mon_rxerr;
		extern unsigned int rxnorec_intv;  // not a count but interval
		extern unsigned char radio_mon_rcvjitter;
		extern enum pair_mode hop_state;
		extern int fhop_offset;
		  static unsigned int tsrx[5];
	      static unsigned int drx[5];
		  unsigned int drx_lc;
	      static unsigned char tsrxos=0;
		  static unsigned char gflag,tsrxos_prev,tsrxos_tail;
		  static unsigned int tcal,lc, i, lc_prev;

// function prototyping
uint32_t wrptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint32_t rdptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint8_t get_si446x_temp() ;
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median);
extern int hop_chn_sel(int offset) ;

/* SI4463 intr handler for bi-directional radio data */
  void si4463_radio_handler(const uint32_t id, const uint32_t index)
	{
		if ((id == ID_PIOA) && (index == SI4463_HOST_INT) && (ctrl_tdma_enable|| si4463_factory_tune.calib_gated)){
			if (timedelta_reset_rx ) {
				memset (tsrx, 0x0, sizeof(tsrx));
				memset (drx, 0x0, sizeof(drx));
				timedelta_reset_rx = false;
			}
			bMain_IT_Status_m = bMain_IT_Status = bRadio_Check_Tx_RX();
		    if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_SENT_PEND_BIT)
		    {
				//just finished sending a return packet.
			    ; // I don't want to deal with dynamic rate control here...
		    }
			if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_RX_PEND_BIT)
			{
		      //Just recieved data from radio
				if (!si4463_factory_tune.calib_gated) {
			  //rx timestamp tracking
			  lc = *DWT_CYCCNT;
			  {
				if (lc < lc_prev)
			  	  drx_lc=lc+(0xffffffff-lc_prev);
			    else // not wrapped yet
			  	  drx_lc=lc -lc_prev;
			    lc_prev = lc;
			  }

			  if(drx_lc < (TDMA_TX_PERIOD*3/2)){
			  //end of asymm tx transmission (TODO: hardcoded for ASYMM_RATION=2
			  tsrxos_prev=tsrxos;
		      tsrxos++; if(tsrxos>4) tsrxos=0;
			  tsrxos_tail = tsrxos+1; if(tsrxos_tail>4)tsrxos_tail=0;
			  tsrx[tsrxos]= lc;
			  if (lc < tsrx[tsrxos_prev])
			  	drx[tsrxos]=lc+(0xffffffff-tsrx[tsrxos_prev]);
			  else // not wrapped yet
			  	drx[tsrxos]=drx_lc=lc -tsrx[tsrxos_prev];
							{
							  //monitoring: rcv timing jitter tracking, fed to rcv pkt stat
						      static int drmin=40000000, drmax=0;
							  static int drmm_cnt=0;
							  drmm_cnt++;
							  if(drmm_cnt==20){
								drmin=40000000;
								drmax=0;}
							  if(drmm_cnt==200){
							    drmm_cnt=0;     //atmel breakpoint setup
								                //observe: 4.1ms jitter
								radio_mon_rcvjitter = (drmax-drmin)/120/100; //0.1ms resolution
							  }

							  if(drmin> drx_lc)
							    drmin=drx_lc;
							  if(drmax< drx_lc)
							    drmax=drx_lc;
			                }
			  gflag=0;
			  for(i=0;i<5;i++) {
				if((drx[i]<TDMA_PERIOD_MAX)&&(drx[i]>TDMA_PERIOD_MIN)) {
			    gflag = gflag + 1;}
			  }
			  if((gflag==5)&&(tsrx[tsrxos]>tsrx[tsrxos_tail]) )  //synchronized
			  {
			    tcal = ((tsrx[tsrxos]/2)+(tsrx[tsrxos_tail]/2))+(TDMA_PERIOD*2);
				tdma_sndthr = tcal + TDMA_RX_TO_TX;
				ctrl_tdma_lock = true;
				fhop_in_search = false;
			  }else
			  {
				  // allow tx isr take the frequ hop action, liyenho
				    lc = *DWT_CYCCNT;
					tdma_sndthr = tsrx[tsrxos] + TDMA_RX_TO_TX;
					fhop_flag = true;
			  }
			  }// asymm tx end processing
				radio_mon_rxcnt++;
        {
          // rx packet loss monitoring
          static uint8_t rxpktcnt_prev=0;
          uint8_t rxpktcnt_curr, rxpktcnt_exp;
          rxpktcnt_curr = ((uint8_t *)gp_rdo_rpacket_l)[2];
          rxpktcnt_exp = rxpktcnt_prev+1;
          if(rxpktcnt_exp != rxpktcnt_curr)
            radio_mon_rxerr++;
          rxpktcnt_prev = rxpktcnt_curr;
        }

			  // The data was already pulled into gp_rdo_rpacket through bRadio_Check_Tx_RX()
			  if(hop_state != IDLE) {
          static bool rxlostflag=false;
          uint32_t wrptr_tmp1, wrptr_tmp2,ov1, ov2;
          wrptr_tmp1=wrptr_rdo_rpacket;
          ov1=wrptr_inc(&wrptr_tmp1, &rdptr_rdo_rpacket, (uint32_t)RDO_RPACKET_FIFO_SIZE,1);//new packet pos
          wrptr_tmp2=wrptr_tmp1;
          ov2=wrptr_inc(&wrptr_tmp2, &rdptr_rdo_rpacket, (uint32_t)RDO_RPACKET_FIFO_SIZE,1);//to be written pos
          if((rxlostflag==false)&&(ov1==0)&&(ov2==0)) {
            //normal condition------------------------------
            wrptr_rdo_rpacket=wrptr_tmp1;
            gp_rdo_rpacket_l = gs_rdo_rpacket + (RDO_ELEMENT_SIZE*wrptr_tmp2);
          }
          else if((rxlostflag==true)&&(ov1==0)&&(ov2==0)){
            //lost packet due to previous fifo full---------
            rxlostflag=false;
            gp_rdo_rpacket_l = gs_rdo_rpacket + (RDO_ELEMENT_SIZE*wrptr_tmp1);
          }
          else {
            //not enough fifo space-------------------------
            gp_rdo_rpacket_l = rpacket_ov;
            rxlostflag=true;
          }
				  }}
	        else { // in cap value tuning phase
				si4463_factory_tune.calib_det_rx =
					si4463_factory_tune.calib_det_rx + 1;
			  }
				/************************************************************/
		  		vRadio_StartRX(pRadioConfiguration->Radio_ChannelNumber,
		  			pRadioConfiguration->Radio_PacketLength
					  );
				rxnorec_intv=0;  //reset rx no receive flag
				/************************************************************/
			}
	  #ifdef  CONFIG_ON_FLASH
			  if (!si4463_factory_tune.calib_req_h && !si4463_factory_tune.calib_gated &&
			  		(0 != si4463_factory_tune.tm_curr)) {
				  uint32_t tdel, tcurr = *DWT_CYCCNT;
				  tm_delta(si4463_factory_tune.tm_curr, tcurr, tdel)
				  	if (RECALIB_INTV_F<=tdel) {
					  	uint8_t median;
					  	median = *(uint8_t*)ul_page_addr_ctune;
						recalibrate_capval((void*)ul_page_addr_mtemp, median);
					}
			  }
	  #endif
		}
	}
uint8_t get_si446x_temp() {
	uint16_t temp1;
	do {
		si446x_get_adc_reading(0x10); // read current temperature reading
		temp1 = (-1+(1<<11))&Si446xCmd.GET_ADC_READING.TEMP_ADC;
	} while (1358>temp1 || 1722<temp1);
	uint8_t ctemp = (899.0/4096.0)*temp1 - 293;
	temp1_intm = temp1;  // aligned access for user query
	return ctemp ;
}
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median) {
		uint8_t ctemp = get_si446x_temp();
		static uint8_t ctemp0= 0;
		int8_t dmc, dcc;
	if (	!ctemp0 || TEMP_DEL_THR<abs(ctemp0-ctemp)) {
		uint8_t mtemp = *(uint8_t*)ul_page_addr_mtemp,
		TCTBL_ACCESS(dmc, mtemp);
		TCTBL_ACCESS(dcc, ctemp);
		tune_cap_str[CAP_VAL_POS] = median + dcc - dmc;
		if (radio_comm_SendCmdGetResp(sizeof(tune_cap_str), tune_cap_str, 0, 0) != 0xFF) {
			while (1) {
				; // Capture error
			}
		}
		ctemp0 = ctemp;
	}
		si4463_factory_tune.tm_curr = *DWT_CYCCNT; // record startup time for recurrent adjustment
}
#endif
