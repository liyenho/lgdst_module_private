/*
 *
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!
 */
#include "si446x_nirq.h"
#include <string.h>
#include "radio.h"
#include "ctrl.h"
#include "conf_board.h"


#include "si446x_api_lib.h"

void Packet_Received_Routine();
volatile si446x_pckt_hdlr_pend pkt;
volatile si446x_mdm_hdlr_pend  mdm;
volatile si446x_chip_hdlr_pend chip;
volatile uint16_t temp1_intm;	// also read by user temperature query
static uint8_t tune_cap_str[] = {RF_GLOBAL_XO_TUNE_2};
extern uint32_t ul_page_addr_ctune, ul_page_addr_mtemp;
extern uint8_t tune_cap_str[];
// time instrumentation
extern volatile uint32_t *DWT_CYCCNT;
extern volatile uint32_t rpacket_idle[RDO_ELEMENT_SIZE];
extern uint32_t rpacket_ov[RDO_ELEMENT_SIZE];
extern unsigned char gs_rdo_rpacket_ovflw;
extern volatile uint32_t wrptr_rdo_rpacket, rdptr_rdo_rpacket;
extern volatile unsigned char bMain_IT_Status, bMain_IT_Status_m; // as global ctrl radio intr flag...
extern volatile bool vid_ant_switch;
extern volatile capv_tune_t si4463_factory_tune;
bool timedelta_reset_rx ;
extern volatile bool ctrl_tdma_lock;
extern volatile bool fhop_in_search, fhop_flag;
extern unsigned int tdma_sndthr;

extern unsigned int radio_mon_rxerr;
extern unsigned int rxnorec_intv;  // not a count but interval
extern unsigned char radio_mon_rcvjitter;
extern enum pair_mode hop_state;
extern int fhop_offset;
static unsigned int tsrx[5];
static unsigned int drx[5];
unsigned int drx_lc;
static unsigned char tsrxos=0;
static unsigned char gflag,tsrxos_prev,tsrxos_tail;
static unsigned int tcal,lc, i, lc_prev;



// function prototyping
uint32_t wrptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint32_t rdptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint8_t get_si446x_temp() ;
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median);

/* SI4463 intr handler for bi-directional radio data */
void si4463_radio_handler(const uint32_t id, const uint32_t index)
{
	if ((id == ID_PIOA) && (index == SI4463_NIRQ_PIN) && (ctrl_tdma_enable|| si4463_factory_tune.calib_gated)){
		if (timedelta_reset_rx ) {
			memset (tsrx, 0x0, sizeof(tsrx));
			memset (drx, 0x0, sizeof(drx));
			timedelta_reset_rx = false;
		}
		bMain_IT_Status_m = bMain_IT_Status = bRadio_Check_Tx_RX();
		if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_SENT_PEND_BIT)
		{
			//just finished sending a return packet.
			; // I don't want to deal with dynamic rate control here...
		}
		if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_RX_PEND_BIT)
		{
			Packet_Received_Routine();
		}else if (bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_STATUS_CRC_ERROR_BIT)
		{
			Packet_Received_Routine();
		}
		#ifdef  CONFIG_ON_FLASH
		if (!si4463_factory_tune.calib_req_h && !si4463_factory_tune.calib_gated &&
		(0 != si4463_factory_tune.tm_curr)) {
			uint32_t tdel, tcurr = *DWT_CYCCNT;
			tm_delta(si4463_factory_tune.tm_curr, tcurr, tdel)
			if (RECALIB_INTV_F<=tdel) {
				uint8_t median;
				median = *(uint8_t*)ul_page_addr_ctune;
				recalibrate_capval((void*)ul_page_addr_mtemp, median);
			}
		}
		#endif
	}
}


uint8_t get_si446x_temp(void) {
	uint16_t temp1;
	do {
		si446x_get_adc_reading(0x10); // read current temperature reading
		temp1 = (-1+(1<<11))&Si446xCmd.GET_ADC_READING.TEMP_ADC;
	} while (1358>temp1 || 1722<temp1);
	uint8_t ctemp = (899.0/4096.0)*temp1 - 293;
	temp1_intm = temp1;  // aligned access for user query
	return ctemp ;
}
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median) {
		uint8_t ctemp = get_si446x_temp();
		static uint8_t ctemp0= 0;
		int8_t dmc, dcc;
	if (	!ctemp0 || TEMP_DEL_THR<abs(ctemp0-ctemp)) {
		uint8_t mtemp = *(uint8_t*)ul_page_addr_mtemp,
		TCTBL_ACCESS(dmc, mtemp);
		TCTBL_ACCESS(dcc, ctemp);
		tune_cap_str[CAP_VAL_POS] = median + dcc - dmc;
		if (radio_comm_SendCmdGetResp(sizeof(tune_cap_str), tune_cap_str, 0, 0) != 0xFF) {
			while (1) {
				; // Capture error
			}
		}
		ctemp0 = ctemp;
	}
		si4463_factory_tune.tm_curr = *DWT_CYCCNT; // record startup time for recurrent adjustment
}



void Packet_Received_Routine(void){
	//Just received data from radio
//			//vRadio_StartRX_variableLength(pRadioConfiguration->Radio_ChannelNumber);	
			//if (USE_915MHZ){
				//vRadio_StartRX(control_channel, RADIO_PKT_LEN);
			//}else{
				//vRadio_StartRX(control_channel,RADIO_LONG_PKT_LEN);
			//}
			//
			//rxnorec_intv=0;  //reset rx no receive flag
			////check timing
			//if (!si4463_factory_tune.calib_gated) {
				////rx timestamp tracking
				//lc = pkt_rcv_timestamp;
				//if (lc < lc_prev){
					//drx_lc=lc+(0xffffffff-lc_prev);
				//}
				//else{
					//drx_lc=lc -lc_prev;
				//}
				//lc_prev = lc;
//
				//if(drx_lc < (TDMA_TX_PERIOD*2/3)){
					////end of asymm tx transmission (TODO: hardcoded for ASYMM_RATION=2
					//hop_watchdog_intv = 0;  //reset the hopping watchdog
					//
					//tsrxos_prev=tsrxos;
					//tsrxos++;
					//if(tsrxos>4) {
						//tsrxos=0;
					//}
					//tsrxos_tail = tsrxos+1; if(tsrxos_tail>4)tsrxos_tail=0;
					//tsrx[tsrxos]= lc;
					//if (lc < tsrx[tsrxos_prev]){
						//drx[tsrxos]=lc+(0xffffffff-tsrx[tsrxos_prev]);
					//} else {
						//drx[tsrxos]=drx_lc=lc -tsrx[tsrxos_prev];
					//}
//
					////monitoring: rcv timing jitter tracking, fed to rcv pkt stat
					//static int drmin=40000000, drmax=0;
					//static int drmm_cnt=0;
					//drmm_cnt++;
					//
					//if(drmm_cnt==80){
						//drmm_cnt=0;     //atmel breakpoint setup
						////observe: 4.1ms jitter
						//radio_mon_rcvjitter = (drmax-drmin)/120/100; //0.1ms resolution
						//drmin=40000000;
						//drmax=0;
					//}
//
					//if(drmin> drx_lc){
						//drmin=drx_lc;
					//}
					//if(drmax< drx_lc){
						//drmax=drx_lc;
					//}
					//gflag=0;
					//for(i=0;i<5;i++) {
						//if((drx[i]<TDMA_PERIOD_MAX)&&(drx[i]>TDMA_PERIOD_MIN)) {
							//gflag = gflag + 1;
						//}
					//}
					//if((gflag==5)&&(tsrx[tsrxos]>tsrx[tsrxos_tail]) )  //synchronized
					//{
						//tcal = ((tsrx[tsrxos]/2)+(tsrx[tsrxos_tail]/2))+((TDMA_PERIOD)*2);
						//tdma_sndthr = tcal + TDMA_RX_TO_TX;
						//ctrl_tdma_lock = true;
						//fhop_in_search = false;
					//}else{
						//// allow tx isr take the frequ hop action, liyenho
						//lc = *DWT_CYCCNT;
						//tdma_sndthr = tsrx[tsrxos] + TDMA_RX_TO_TX;
						//fhop_flag = true;
					//}
				//}// asymm tx end processing
				//radio_mon_rxcnt++;
				//
			//}
			//else { // in cap value tuning phase
				//si4463_factory_tune.calib_det_rx = si4463_factory_tune.calib_det_rx + 1;
			//}
	//
}
