/*
 *
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!
 */
#include "si446x_nirq.h"
#include <string.h>
#include "radio.h"
#include "ctrl.h"
#include "Radio_Buffers.h"

#ifdef RADIO_SI4463
 #include "si446x_api_lib.h"
 void si4463_radio_handler(const uint32_t id, const uint32_t index);
	volatile si446x_pckt_hdlr_pend pkt;
	volatile si446x_mdm_hdlr_pend  mdm;
	volatile si446x_chip_hdlr_pend chip;
	volatile uint16_t temp1_intm;	// also read by user temperature query
	static uint8_t tune_cap_str[] = {RF_GLOBAL_XO_TUNE_2};
	extern uint32_t ul_page_addr_ctune, ul_page_addr_mtemp;
	extern uint8_t tune_cap_str[];
	// time instrumentation
	extern volatile uint32_t *DWT_CYCCNT;
	extern volatile uint32_t gs_rdo_rpacket[RDO_RPACKET_FIFO_SIZE*RDO_ELEMENT_SIZE];
  extern unsigned int *gp_rdo_rpacket;
	extern volatile uint32_t rpacket_idle[RDO_ELEMENT_SIZE];
  extern uint32_t rpacket_ov[RDO_ELEMENT_SIZE];
	extern unsigned char gs_rdo_rpacket_ovflw;
	
	extern volatile unsigned char bMain_IT_Status; // as global ctrl radio intr flag...
	  extern volatile bool ctrl_tdma_enable;
	  extern volatile capv_tune_t si4463_factory_tune;
	  extern unsigned int tdma_sndthr;
	  extern unsigned int  radio_mon_rxcnt;
	  extern uint8_t hop_id[HOP_ID_LEN];
	  extern enum pair_mode hop_state;
extern unsigned char snd_asymm_cnt;
extern unsigned int  snd_asymm_rdptr;
extern volatile uint32_t gs_rdo_tpacket[RDO_TPACKET_FIFO_SIZE*RDO_ELEMENT_SIZE];
extern unsigned int *gp_rdo_tpacket_l;
extern volatile uint32_t wrptr_rdo_tpacket;
extern volatile uint32_t rdptr_rdo_tpacket;

// function prototyping
uint32_t wrptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint32_t rdptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint8_t get_si446x_temp() ;
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median);

/* SI4463 intr handler for bi-directional radio data */
  void si4463_radio_handler(const uint32_t id, const uint32_t index)
	{
		if ((id == ID_PIOB) && (index == SI4463_HOST_INT) && (ctrl_tdma_enable|| si4463_factory_tune.calib_gated)){
			bMain_IT_Status = bRadio_Check_Tx_RX();
		    if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_SENT_PEND_BIT)
		    {
			    // I don't want to deal with dynamic rate control here...
				//ASYMM_RATIO multi-send done here now
				if(snd_asymm_cnt>0){
					snd_asymm_cnt--;
					if(fifolvlcalc(wrptr_rdo_tpacket, rdptr_rdo_tpacket, RDO_TPACKET_FIFO_SIZE)<1)
					  { //idle packet case
						  //add idle packet to the output queue
						  Queue_Control_Idle_Packet();
					  }
					//rdptr_inc(&wrptr_rdo_tpacket, &rdptr_rdo_tpacket, RDO_TPACKET_FIFO_SIZE, 1);
					gp_rdo_tpacket_l = gs_rdo_tpacket + (RDO_ELEMENT_SIZE*rdptr_rdo_tpacket);
					//vRadio_StartTx_Variable_Length(control_channel, gp_rdo_tpacket_l, RADIO_PKT_LEN);
					//vRadio_StartTx(control_channel, gp_rdo_tpacket_l, RADIO_PKT_LEN);
					Control_Send_Event();
				}
		    }
			if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_RX_PEND_BIT)
			{
				//Just received data from radio
				if (!si4463_factory_tune.calib_gated) {
					radio_mon_rxcnt++;
					/************************************************************/
				}
		  		//vRadio_StartRX_variableLength(control_channel);
				vRadio_StartRX(control_channel, RADIO_PKT_LEN);
				/************************************************************/
			}
	  #ifdef  CONFIG_ON_FLASH
		 if (!si4463_factory_tune.calib_req_h && !si4463_factory_tune.calib_gated &&
		  (0 != si4463_factory_tune.tm_curr)) {
			  uint32_t tdel, tcurr = *DWT_CYCCNT;
			  tm_delta(si4463_factory_tune.tm_curr, tcurr, tdel)
			  if (RECALIB_INTV_F<=tdel) {
				  uint8_t median = *(uint8_t*)ul_page_addr_ctune;
				  recalibrate_capval((void*)ul_page_addr_mtemp, median);
			  }
		  }
	  #endif
		}
	}
uint8_t get_si446x_temp() {
	uint16_t temp1;
	do {
		si446x_get_adc_reading(0x10); // read current temperature reading
		temp1 = (-1+(1<<11))&Si446xCmd.GET_ADC_READING.TEMP_ADC;
	} while (1358>temp1 || 1722<temp1);
	uint8_t ctemp = (899.0/4096.0)*temp1 - 293;
	temp1_intm = temp1;  // aligned access for user query
	return ctemp ;
}
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median) {
		uint8_t ctemp = get_si446x_temp();
		static uint8_t ctemp0= 0;
		int8_t dmc, dcc;
	if (	!ctemp0 || TEMP_DEL_THR<abs(ctemp0-ctemp)) {
		uint8_t mtemp = *(uint8_t*)ul_page_addr_mtemp,
		TCTBL_ACCESS(dmc, mtemp);
		TCTBL_ACCESS(dcc, ctemp);
		tune_cap_str[CAP_VAL_POS] = median + dcc - dmc;
		if (radio_comm_SendCmdGetResp(sizeof(tune_cap_str), tune_cap_str, 0, 0) != 0xFF) {
			while (1) {
				; // Capture error
			}
		}
		ctemp0 = ctemp;
	}
		si4463_factory_tune.tm_curr = *DWT_CYCCNT; // record startup time for recurrent adjustment
}
#endif
