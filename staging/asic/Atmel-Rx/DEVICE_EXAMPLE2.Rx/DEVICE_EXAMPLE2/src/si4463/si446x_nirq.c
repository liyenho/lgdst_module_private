/*
 *
 * THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!
 */
#include "si446x_nirq.h"
#include <string.h>
#include "radio.h"

#ifdef RADIO_SI4463
 #include "si446x_api_lib.h"
 void si4463_radio_handler(const uint32_t id, const uint32_t index);
	volatile si446x_pckt_hdlr_pend pkt;
	volatile si446x_mdm_hdlr_pend  mdm;
	volatile si446x_chip_hdlr_pend chip;
	volatile uint16_t temp1_intm;	// also read by user temperature query
	static uint8_t tune_cap_str[] = {RF_GLOBAL_XO_TUNE_2};
	extern uint32_t ul_page_addr_ctune, ul_page_addr_mtemp;
	extern uint8_t tune_cap_str[];
	// time instrumentation
	extern volatile uint32_t *DWT_CYCCNT;
	extern volatile uint32_t gs_rdo_rpacket[RDO_RPACKET_FIFO_SIZE*RDO_ELEMENT_SIZE];
  extern unsigned int *gp_rdo_rpacket, *gp_rdo_rpacket_l;
	extern volatile uint32_t rpacket_idle[RDO_ELEMENT_SIZE];
  extern uint32_t rpacket_ov[RDO_ELEMENT_SIZE];
	extern unsigned char gs_rdo_rpacket_ovflw;
	extern volatile uint32_t wrptr_rdo_rpacket, rdptr_rdo_rpacket;
	extern volatile unsigned char bMain_IT_Status; // as global ctrl radio intr flag...
	  extern volatile bool ctrl_tdma_enable;
	  extern volatile capv_tune_t si4463_factory_tune;
	  extern unsigned int tdma_sndthr;
	  extern unsigned int  radio_mon_rxcnt;
	  extern uint8_t hop_id[HOP_ID_LEN];
	  extern enum pair_mode hop_state;
extern unsigned char snd_asymm_cnt;
extern unsigned int  snd_asymm_rdptr;
extern volatile uint32_t gs_rdo_tpacket[RDO_TPACKET_FIFO_SIZE*RDO_ELEMENT_SIZE];
extern unsigned int *gp_rdo_tpacket_l;
extern volatile uint32_t wrptr_rdo_tpacket;
extern volatile uint32_t rdptr_rdo_tpacket;

// function prototyping
uint32_t wrptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint32_t rdptr_inc(uint32_t *wrptr,  uint32_t *rdptr, uint32_t fifodepth, int step);
uint8_t get_si446x_temp() ;
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median);

/* SI4463 intr handler for bi-directional radio data */
  void si4463_radio_handler(const uint32_t id, const uint32_t index)
	{
		if ((id == ID_PIOB) && (index == SI4463_HOST_INT) && (ctrl_tdma_enable|| si4463_factory_tune.calib_gated)){
			bMain_IT_Status = bRadio_Check_Tx_RX();
		    if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_SENT_PEND_BIT)
		    {
			    ; // I don't want to deal with dynamic rate control here...
				//ASYMM_RATIO multi-send done here now
				if(snd_asymm_cnt>0){
					snd_asymm_cnt--;
					if(snd_asymm_rdptr>= (RDO_TPACKET_FIFO_SIZE-1)) snd_asymm_rdptr=0;
					else                                            snd_asymm_rdptr++;
					//must cover both tpacket_idle and gs_rdo_tpacket types
					if(snd_asymm_rdptr==0) gp_rdo_tpacket_l = gs_rdo_tpacket;
					else                   gp_rdo_tpacket_l= gp_rdo_tpacket_l+RDO_ELEMENT_SIZE;
					vRadio_StartTx_Variable_Packet(pRadioConfiguration->Radio_ChannelNumber, gp_rdo_tpacket_l,
					RADIO_PKT_LEN); //pRadioConfiguration->Radio_PacketLength);
				}

		    }
			if(bMain_IT_Status == SI446X_CMD_GET_INT_STATUS_REP_PH_PEND_PACKET_RX_PEND_BIT)
			{
				if (!si4463_factory_tune.calib_gated) {
				radio_mon_rxcnt++;
				/************************************************************/
			  // The data was already pulled into gp_rdo_rpacket through bRadio_Check_Tx_RX()
			  if(hop_state != IDLE) {
  			  static bool rxlostflag=false;
  			  uint32_t wrptr_tmp1, wrptr_tmp2,ov1, ov2;
  			  wrptr_tmp1=wrptr_rdo_rpacket;
  			  ov1=wrptr_inc(&wrptr_tmp1, &rdptr_rdo_rpacket, (uint32_t)RDO_RPACKET_FIFO_SIZE,1);//new packet pos
  			  wrptr_tmp2=wrptr_tmp1;
  			  ov2=wrptr_inc(&wrptr_tmp2, &rdptr_rdo_rpacket, (uint32_t)RDO_RPACKET_FIFO_SIZE,1);//to be written pos
  			  if((rxlostflag==false)&&(ov1==0)&&(ov2==0)) {
    			  //normal condition------------------------------
    			  wrptr_rdo_rpacket=wrptr_tmp1;
    			  gp_rdo_rpacket_l = gs_rdo_rpacket + (RDO_ELEMENT_SIZE*wrptr_tmp2);
  			  }
  			  else if((rxlostflag==true)&&(ov1==0)&&(ov2==0)){
    			  //lost packet due to previous fifo full---------
    			  rxlostflag=false;
    			  gp_rdo_rpacket_l = gs_rdo_rpacket + (RDO_ELEMENT_SIZE*wrptr_tmp1);
  			  }
  			  else {
    			  //not enough fifo space-------------------------
    			  gp_rdo_rpacket_l = rpacket_ov;
    			  rxlostflag=true;
  			  }
	        }}
	        else { // in cap value tuning phase
				si4463_factory_tune.calib_det_rx =
					si4463_factory_tune.calib_det_rx + 1;
        }
		  		vRadio_StartRX(pRadioConfiguration->Radio_ChannelNumber,
				   RADIO_PKT_LEN);
				/************************************************************/
			}
	  #ifdef  CONFIG_ON_FLASH
		 if (!si4463_factory_tune.calib_req_h && !si4463_factory_tune.calib_gated &&
		  (0 != si4463_factory_tune.tm_curr)) {
			  uint32_t tdel, tcurr = *DWT_CYCCNT;
			  tm_delta(si4463_factory_tune.tm_curr, tcurr, tdel)
			  if (RECALIB_INTV_F<=tdel) {
				  uint8_t median = *(uint8_t*)ul_page_addr_ctune;
				  recalibrate_capval((void*)ul_page_addr_mtemp, median);
			  }
		  }
	  #endif
		}
	}
uint8_t get_si446x_temp() {
	uint16_t temp1;
	do {
		si446x_get_adc_reading(0x10); // read current temperature reading
		temp1 = (-1+(1<<11))&Si446xCmd.GET_ADC_READING.TEMP_ADC;
	} while (1358>temp1 || 1722<temp1);
	uint8_t ctemp = (899.0/4096.0)*temp1 - 293;
	temp1_intm = temp1;  // aligned access for user query
	return ctemp ;
}
void recalibrate_capval (void* ul_page_addr_mtemp, uint8_t median) {
		uint8_t ctemp = get_si446x_temp();
		static uint8_t ctemp0= 0;
		int8_t dmc, dcc;
	if (	!ctemp0 || TEMP_DEL_THR<abs(ctemp0-ctemp)) {
		uint8_t mtemp = *(uint8_t*)ul_page_addr_mtemp,
		TCTBL_ACCESS(dmc, mtemp);
		TCTBL_ACCESS(dcc, ctemp);
		tune_cap_str[CAP_VAL_POS] = median + dcc - dmc;
		if (radio_comm_SendCmdGetResp(sizeof(tune_cap_str), tune_cap_str, 0, 0) != 0xFF) {
			while (1) {
				; // Capture error
			}
		}
		ctemp0 = ctemp;
	}
		si4463_factory_tune.tm_curr = *DWT_CYCCNT; // record startup time for recurrent adjustment
}
#endif
